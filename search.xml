<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql的sql语法学习</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="- 数据库的增删改查"></a>- 数据库的增删改查</h2><p><strong>命令行打开mysql:</strong> mysql -uroot -p1234</p><p><strong>查询数据库：</strong> show databases;<br><strong>创建数据库：</strong> </p><ul><li>直接法：create database 库名;</li><li>间接法：create database if not exists;</li></ul><p><strong>删除数据库：</strong></p><ul><li>直接法：drop database 库名;</li><li>间接法：drop database if exists 库名;</li></ul><p><strong>使用数据库：</strong> use 库名<br><strong>查看当前所使用的数据库：</strong> select database();<br>##常用数据类型<br><strong>数值型：</strong> int,float,double <u>(用法：double(总长度(总长度为小数点前后总个数),小数点后保留位数),eg：double(5,2)表示整数范围取值0~100,小数点保留2位)</u><br><strong>日期和时间类型：</strong> date(日期值),time(时间值或持续时间),year(年份),datetime(年月日时分秒)<br><strong>字符串类型：</strong> char,varchar <u>用法：char()表示定长字符串,无论得到的字符串长度多少,都按括号内规定的空间存储,因此存储性能高,浪费空间(空间换时间);varchar()表示变长字符串,先计算得到的字符串长度,再根据这串长度分配空间存储,因此存储性能低,节约空间(时间换空间)</u></p><h2 id="DDL——操作表-要执行以下操作得先进入相关数据库中"><a href="#DDL——操作表-要执行以下操作得先进入相关数据库中" class="headerlink" title="- DDL——操作表(要执行以下操作得先进入相关数据库中"></a>- DDL——操作表(要执行以下操作得先进入相关数据库中</h2><p><strong>查询表：</strong> show tables;<br><strong>查询表的结构:</strong> desc 表名;<br><strong>创建表：</strong> </p><ul><li>create table 表名(<br>  字段1 数据类型1,<br>  字段2 数据类型2,<br>  ………<br>  字段n 数据类型n(此处无,)<br>  );</li></ul><p><strong>删除表：</strong> </p><ul><li>直接法：drop table 表名;</li><li>间接法：drop table if exists 表名;</li></ul><p><strong>修改表：</strong> </p><ol><li>修改表名：alter table 表名 rename to 新表名;</li><li>添加一列新数据：alter table 表名 add 列名 数据类型;</li><li>修改数据类型：alter table 表名 modify 列名 新数据类型;</li><li>修改列名和数据类型：alter table 表名 change 列名 新列名 新数据类型;</li><li>删除列：alter table 表名 drop 列名;</li></ol><h2 id="DML——操作数据"><a href="#DML——操作数据" class="headerlink" title="- DML——操作数据"></a>- DML——操作数据</h2><p><strong>查询所有数据：</strong> select * from 表名;<br><strong>添加：</strong> </p><ol><li>给指定的列添加数据：insert into 表名(列名1,列名2,……) values(值1,值2,……);</li><li>给全部列添加数据：insert into 表名 values(值1,值2,……);<em>注：不建议如此做,建议使用上面的方法,将所有列名打出来,这样更为直观</em></li><li>批量添加数据： insert into 表名(列名1,列名2,……) values(值1,值2,……),(值      1,值2,……);<br><em>注：即在values处按格式以此添加就好,中间用逗号隔开</em></li></ol><p><strong>修改表数据：</strong> update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,… where 条件(列名n&#x3D;值        n)<br><em>特别注意：一定要加上条件,不然会导致表中全部数据被修改,且该行为无法撤销！！！</em><br><strong>删除表数据：</strong> delete from 表名 where 条件<br><em>特别注意：一定要加上条件,不然会导致表中全部数据被修改,且该行为无法撤销！！！</em></p><h2 id="DQL——查询数据-的意思为全部-可放于列名处"><a href="#DQL——查询数据-的意思为全部-可放于列名处" class="headerlink" title="- DQL——查询数据(*的意思为全部,可放于列名处)"></a>- DQL——查询数据(*的意思为全部,可放于列名处)</h2><p><em>注:一下查询方法并非完全独立,可组合进行</em></p><p><strong>基础查询：</strong> select 列名1 ,列名2 from 表名;<br><code> eg: select name,math from students;</code></p><p><strong>去重查询：</strong> select distinct 列名1,列名2 from 表名;<br><code>eg:select distince name,id from students;</code><br><strong>加别名查询：</strong> select 列名1 as 注释,列名2 as 注释 from表名;<br><code> eg:select name as 小王 from students;</code></p><p><strong>条件查询(where)：</strong> select 列名1 from 表名 where 条件;<br><u>eg:查询名字中含有“花”的学员都有谁:</u> <code>select name from students like %花%;</code><br><em>(可选条件与java运算符一致,特别记忆：是NULL： is null;不是NULL： is not null;模糊查询：like(_下划线表示单个模糊字符,%百分号表示多个任意字符; 日期差值：datediff (日期1, 日期2) 得到的结果是日期1与日期2相差的天数)</em></p><p><strong>排序查询(order by)：</strong> select * from 表名 order by 列名1 排序方法,列名2 排序方法(asc为升序,desc为降序,默认升序);<br><u>eg:查询学生信息,按年龄升序排列:</u> <code>select * from students order by age asc;</code><br> <em>(若有多个排序要求,则先满足前面的,在执行后面的)</em></p><p><strong>聚合查询：</strong> select 聚合函数名(列名)from 表名;(聚合函数：统计数量：count;求最大值：max;求最小值：min;求和：sum;求平均值：avg;<em>特殊的：null值不参与所有聚合函数运算;count配套的列名一般直接用</em>)*<br><u>eg: 求全班数学成绩平均分:</u> <code> select avg(math) from students;</code></p><p><strong>分组查询(group by)：</strong> select 字段列(聚合函数,参与分组列) from 表名 【where 分组前的条件限定】group by 列名 【having 分组后的条件筛选】<br><u>eg:查询男女同学各自平均分和人数：</u> <code>select sex,avg(math),count(*) from students group by sex;</code><br><u>eg:查询男女同学各自平均分和人数,要求分数低于70分不参与分组,分组后人数需大于2：</u> <code>select sex,avg(math),count(*) from students where math&gt;70 group by sex having count(*)&gt;2;</code><br><em>特别注意：分组之后查询的字段为聚合函数和参与分组的列,查询其他的列无意义   执行顺序：where&gt;聚合函数&gt;having,即where是对分组前进行限定,不满足条件不参与分组,故where后不接聚合函数,having是对分组结果进行筛选,接聚合函数。</em></p><p><strong>分页查询(limit)：</strong> select 列名 from 表名 limit 起始索引(起始索引&#x3D;(查询页数-1)*每页显示条数)每页显示条数;<br><u>eg：每页显示10条数据,查询第一页数据：</u> <code> select * from students limit 0,10;</code></p><p><strong>笛卡尔积：</strong> 集合A有m个数据,集合B有n个数据,A,B集合所有组合情况称为笛卡尔积。</p><p><strong>多表查询(即在表名位置输入多个表)：</strong> </p><ol><li><strong>连接查询:</strong><ul><li><strong>内连接查询(相当于查询A,B集合的交集)：</strong><br> –隐式内连接：select 列名 from 表1,表2… where 条件;<br> –显示内连接：select 列名 from 表1 join 表2 on 条件</li><li><strong>外连接查询(相当于查询某表所有数据和交集部分数据):</strong><br> –左外连接： select 列名 from 表1 left join 表2 on 条件<br> –右外连接(本质上与左外连接没区别,推荐用左)：select 列名 from 表1 right join 表2 on 条件</li></ul></li><li><strong>子查询(嵌套查询)：</strong><ul><li><strong>单行单列：</strong> select 列名 from 表名 where 条件&gt;子查询(select 列名……)<br>  <u>eg：查询年龄比张三大的人信息：</u> <code>select * from emp where age&gt;(select age from emp where name =&#39;张三&#39;);</code></li><li><strong>多行多列(将经过筛选的表放入from后面的表中)：</strong> select 列名 from (子查询),表1 where 条件;</li></ul></li></ol><h2 id="约束—————"><a href="#约束—————" class="headerlink" title="- 约束—————"></a>- 约束—————</h2><p><strong>约束的概念：</strong> </p><ul><li>约束是作用于表中列上的规则,用于限制加入表的数据;</li><li>约束的存在保证了数据库中数据的正确性、有效性和完整性</li></ul><table><thead><tr><th align="left">约束名称</th><th align="center">描述</th><th align="right">关键字</th></tr></thead><tbody><tr><td align="left">非空约束</td><td align="center">保证列中所有数据不存在null值</td><td align="right">not null</td></tr><tr><td align="left">唯一约束</td><td align="center">保证列中所有数据不相同</td><td align="right">unique</td></tr><tr><td align="left">主键约束</td><td align="center">主键是一行数据的唯一标识,要求非空且唯一</td><td align="right">primary key</td></tr><tr><td align="left">检查约束(mysql不存在)</td><td align="center">保证列中的值满足某一条件</td><td align="right">check</td></tr><tr><td align="left">默认约束</td><td align="center">保存数据时,未指定的值采用默认值</td><td align="right">default</td></tr><tr><td align="left">外键约束</td><td align="center">外键使两个表的数据建立链接,保证数据的一致性与完整性</td><td align="right">foreign key</td></tr></tbody></table><p><strong>非空,唯一,主键,默认约束的例子：</strong><br>创建员工表：(多个约束条件平行存在,不需要连接符连接)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,<span class="comment">--员工id,主键且自增长</span></span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>, –员工姓名,非空且唯一</span><br><span class="line">joindate <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> –入职日期,非空</span><br><span class="line">salary <span class="keyword">double</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,<span class="comment">--工资,非空</span></span><br><span class="line">bonus <span class="keyword">double</span> (<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0</span> –奖金,如果没有默认为<span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>自增长：</strong> auto_increment 当列为数字类型并且被唯一约束所修饰可使用<br><strong>外键约束(将从表中某一列名与主表某一列名关联,形成物理上的关系)：</strong> </p><ul><li><strong>添加外键：</strong> <ul><li>创建表的时候添加外键约束：于表最后一行添加逗号“,” constraint  外键名(fk_从表名_主表名) foreign key(从表列名) references 主表表名(主表列名)</li><li>建完表后添加外键约束：alter table 表名 add constraint fk_从表名_主表名 foreign key(从表列名) references 主表表名(主表列名);<br><u>eg:将员工表emp中的部门(列名：dep_id)与部门表dept的部门(列名：id)进行外键约束：</u > <code>constraint fk_emp_dept foreign key(dep_id)references dept(id)</code></li></ul></li><li><strong>删除外键：</strong> alter table 从表表名 drop foreign key fk_从表名_主表名;</li></ul><h2 id="事务————"><a href="#事务————" class="headerlink" title="- 事务————"></a>- 事务————</h2><p><strong>事务简介：</strong> </p><ul><li>数据库的事务是一种机制、一个操作序列,包含了一组数据库操作命令</li><li>事务把所有的命令作为一个<strong>整体</strong>向系统提交或撤销操作请求,即这一组数据库命令要么同时成功,要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul><p><strong>开启事务：</strong> begin;<br><strong>提交事务：</strong> commit;<br><strong>回滚事务(回到开启事务时的数据)：</strong> rollback;</p><p><strong>事务的四大特征(ACID)：</strong></p><ul><li><strong>原子性(Atomicity) ：</strong> 事务是不可分割的最小操作单位,要么同时成功,要么同时失败</li><li><strong>一致性(Consistency)：</strong> 事务完成时,必须使所有的数据都保持一致状态</li><li><strong>隔离性(Isolation)：</strong> 多个事务之间,操作的可见性</li><li><strong>持久性(Durability)：</strong> 事务一旦提交或回滚,它对数据库中的数据的改变就是永久的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
